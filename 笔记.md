# 笔记

## ref属性

1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上的是组件实例对象（vc）
3. 使用方式：
   打标识：

    ```js
      <h1 v-text="msg" ref="title"></h1>
      <button ref="btn" @click="showDOM">点我输出上方的DOM元素</button>
      <School ref="sch"></School>
    ```

   获取：

    ```js
    this.$refs.xxx
    ```

   备注：在组件上标识id属性，获取到的是组件的HTML结构。

    ```js
    <School id="sch"></School>
    ```

## 配置项props

功能：让组件接收外部传过来的数据
>更常见于：你有一个组件，但是data中的数据你已经写好了，别人也想用这个组件，但是数据不一样的情况。你可以使用props配置型，所以这样写可能是复用率最高的。

- 父组件给子组件传递数据

### 传递数据

```js
  <Student name='昂劳务' sex='男' :age='18'></Student>
```

### 接收数据（组件内部）

1. 只接收，没有任何限制

  ```js
    props: ['name','sex','age'] // 简单接收
  ```

2. 限制类型

  ```js
    props: {
      name: String,
      age: Number, 
      sex: String
    } 
  ```

3. 限制类型、必要性和指定默认值

  ```js
    props: {
    name: {
      type: String,
      require: true // name是必要的
    },
    age: {
      type: Number,
      default: 99 // 默认值
    },
    sex: {
      type: String,
      require: true
    }
  }
  ```

### 备注

props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告。
如果业务确实需要修改，那么可以赋值props的内容到data中一份，然后渲染和修改data中的数据。

```js
  // html
  <h2>学生年龄：{{ this.ageFlag }}</h2>

  // data
  data() {
    return {
      msg:'我是谁？',
      ageFlag: this.age // *
    }
  },

  //methods
  methods: {
    updateAge(){
      this.ageFlag++;
    }
  },
```

## mixin配置项

用于当两个组件都要相同的东西时，抽离出来写到一个文件中，然后再引入。
可以把多个组件共用的配置提取成一个混入对象。

### 使用方式

1. 定义混合（在单独的文件中）
   把多个组件的相同部分抽离到一个单独的[文件中](.src/mixin.js)中,在组件中是什么样的，在mixin中就是什么样的。

   ```js
    export const mixin = {
      methods: {
        showName(){
          alert(this.name);
        }
      }
    }
    export const dataMixin = {
      data() {
        return {
          testNum: 99
        }
      },
    }
   ```

2. 使用混合
   1. 全局混合：（在[main文件](.src/main.js)中）

   ```js
    import name from 'xxx'
    Vue.mixin(name);
   ```

   2. 局部混合：（在当前组件文件）

   ```js
    import name from 'xxx' 
    mixins:[name,...];
   ```

### 备注

对于mixin混合，若发生冲突，Vue会让原有组件中的配置优先生效。但生命周期函数除外。

## 插件

用于增强Vue
本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的参数数据。

### 定义插件

在一个新的文件夹plugins.js中定义插件：

```js
  export default {
    install(Vue,options) {
      // 1. 添加全局过滤器
      Vue.filter(...)

      // 2. 添加全局指令
      Vue.directive(...)

      // 3. 配置全局混合
      Vue.mixin(...)

      // 4. 在原型上添加方法
      Vue.prototype.$myMethod=function am(params) {
        
      }
      Vue.prototype.$myProperty=xxx
    }
}
```

### 使用插件

```js
  import plugin from './src/plugins.js' // 在new Vue之前。
  Vue.use($插件名)
```

## scoped样式

### 引入问题

:question:在多个组件中，多个组件的样式虽然是分开设置的，但最后（浏览器渲染时）Vue还是会合到一张样式表中，这就有可能造成样式class重名的问题。

### 解决

- 当重叠时，谁在APP中最后引入，就以谁为准。
- App组件中写的样式不适合使用scoped属性，因为所有的组件都汇总到了App组件，它的样式应该用来写全局样式比较。

  ```html
  <style scoped lang='less'>
    .demo2 {
      background-color: orange;
      .qwe {
        font-size: 40px;
      }
    }
  </style>
  ```

- scoped属性的实现原理=>**属性选择器**
![image.png](https://pic.rmb.bdstatic.com/bjh/19ead2a9001dc8bcc4dc2608999d02d3.jpeg)
![image.png](https://pic.rmb.bdstatic.com/bjh/ba6c862bac0f1b46556b610bf2d221a8.jpeg)
- style中的lang属性是css预编译语言，如lang='less',但是脚手架处理不了less，需要安装less。命令：

  ```js
  npm i less-loader
  ```

- 查看webpack的版本

  ```js
  npm view webpack versions
  ```

## 组件化编码流程（通用）

最忌讳的是给你一个需求，你拿过来直接就写，想都不想。

### 实现静态组件

抽取组件，使用组件实现静态页面效果。

1. 分析一共可以拆分成多少组件。
2. 组件的划分是按照功能点来划分的。
3. 有时候你拆完组件之后，感觉很难给起名，那么就有可能意味着**拆得不合理**。
    ![image.png](https://pic.rmb.bdstatic.com/bjh/b75b490b68966569c346fd06d522b656.jpeg)
4. 开发中，组件起名都是多个单词组成的。eg：个人中心的头部 => `UserHeader`。
5. 整体组件的层级引入搭建好。

- id的生成：uuid和nanoid
  安装nanoid库:

  ```js
    npm i nanoid
  ```

  引入nanoid

  ```js
    // 引入nanoid
    import {nanoid} from 'nanoid'
  ```

  使用nanoid

  ```js
    nanoid();  // 是一个函数，返回相应的字符串。
  ```

### 展示动态数据

### 交互--从绑定事件监听开始

![image.png](https://pic.rmb.bdstatic.com/bjh/59e551102b98f81c4a6706b478d9b636.jpeg)

- 数据在哪，那么对数据的操作就应该在哪里的methods中
- 不建议使用v-model修改props传过来的数据
![image.png](https://pic.rmb.bdstatic.com/bjh/fb9cd874b4752dea5822c942dfdafa0a.jpeg)
props是只读的，虽然props只是执行了浅层的监视（即修改对象中的某个属性的值时，props是监测不到的--这里是todo对象中的completed）。

## TODO案例总结

1. 组件化编码流程：
    1. 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突
    2. 实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件再用：
        1. 一个组件在用：放在组件自身即可。
        2. 一些组件在用：放在他们共同的父组件上（状态提升）。
        1. 实现交互：从绑定事件开始。
2. props传输数据适用于：
   1. 父组件==》子组件 通信
   2. 子组件==》父组件 通信 （要求父先给子一个函数）
3. 使用v-model时要切记：v-model绑定的值不能时props传过来的值，因为props是不可以被修改的。
4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。

## WebStorage

浏览器端通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制。

存储内容大小一般支持5MB左右（不同浏览器可能不一样）

### localStorage

本地存储，需要手动清除才会消失。

### sessionStorage

会话存储，浏览器关闭之后会消失。

### 相关API

localStorage和sessionStorage属性的API完全相同

- `xxxxStorage.setItem('key','value');`

 ​  该方法接收一个键和值作为参数，会把键值对放入存储中，如果键值名忖左，则更新其对应的值。

- `xxxxStorage.getItem('key');`

 ​  该方法接收一个键名作为参数，返回键名对应的值。

- `xxxxStorage.removeItem('key');`

 ​  该方法接收一个键名作为参数，并把该键名从存储中删除。

- `xxxxStorage.clearItem();`

 ​  该方法会清空存储中的所有数据。

### 备注

1. `xxxxStorage.getItem('key');`中key不在存储中，那么返回的是`null`
2. `JSON.parse(null)`的结果依然是`null`

## 组件自定义事件

>JS的内置事件如click、keyup等是用于HTML元素的
 组件自定义事件是给组件用的

### 回顾子给父传递事件的另一个方法“使用props进行传递数据”

```js
  // 1.在父组件的子组件标签中使用props传递一个函数
  <School :getSchoolName="getSchoolName"></School> 
  // 2.在子组件的props中接收这个函数
  props: ["getSchoolName"],
  // 3.在子组件中使用这个函数，并传递此子组件的数据
  methods: {
    sendSchoolName() {
      console.log("发送了学校名字");
      this.getSchoolName(this.name); // 父组件穿过来的函数被调用，子组件的数据被传递过去了。
    },
  },
  // 4.在父组件中使用接收到的子组件的数据
  methods: {
  getSchoolName(schoolName) {
    console.log("App收到了学校名", schoolName);
  }, 
```

### 自定义组件的作用

适用于 子组件 给 父组件 传递数据

### 自定义组件如何用于子给父传递事件

#### 方法一：通过给子组件标签绑定一个自定义事件实现

在父组件的子组件标签中给子组件绑定自定义事件

1. `<Demo @selfSet="test"/>`
2. `<Demo v-on:selfSet="test"/>`

```js
  // 在父组件的子组件标签中给子组件绑定自定义事件
  <Student v-on:selfSet="getStudentName" @demo="m1"></Student> // 自定义事件中的回调函数写在父组件中
  // 在子组件中触发自定义事件
  // 触发student组件实例身上的selfSet事件
  this.$emit("selfSet", this.name, 666, 888, 900);  // 事件触发后，在父组件中的getStudentName函数被调用，从而达到从子组件向父组件传递数据。
```

#### 方法二：使用ref属性

```js
  // 在父组件的子组件标签中使用ref打标识
  <Demo ref="demo"/>
  // 在父组件中
  mounted() {
    this.$refs.student.$on("selfSet", this.getStudentName); // 绑定自定义事件
    // this.$refs.student.once("selfSet", this.getStudentName); // 绑定自定义事件(一次性)
  },
```

#### 备注

1. 触发自定义事件：`this.$emit('selfSet',数据)`
2. 解绑自定义事件：`this.$off('selfSet')`
3. 组件上也可以绑定原生DOM事件，需要使用`.native`修饰符
4. 注意：通过`this.$refs.student.$on("selfSet", this.getStudentName);`绑定自定义事件时，回调要么配置在methods中，要么使用箭头函数，否则this指向会出问题。

## 全局事件总线(GlobalEventBus)

原理图：
![image.png](https://pic.rmb.bdstatic.com/bjh/e54578929df8ac303cb9c1ccb7d4d776.jpeg)

全局事件总线是一种组件间通信的方式，适用于任意组件间的通信。

### 安装全局事件总线

```js
  // 创建vm
  new Vue({
    ......
    beforeCreate() {
      Vue.prototype.$bus = this // 安装全局事件总线，$bus就是当前应用的vm
    },
    ......
  })
```

### 使用事件总线

1. 接收数据组件：A组件想要接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。

   ```js
    // 方法一：回调函数使用箭头函数
      mounted() {
        // console.log("School", this.x);
        this.$bus.$on("sendName", (data) => {
          console.log("我是School组件，收到了数据", data);
        });
      },
    // 方法二：回调函数提前在methods中定义
    methods: {
      demo(data){
        ...
      }
    },
    mounted() {
      // console.log("School", this.x);
      this.$bus.$on("sendName", this.demo);
    },
   ```

2. 提供数据的组件：`this.$bus.$emit('xxx',data)`
3. 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。

   ```js
    beforeDestroy() {
     this.$bus.$off('sendName');  // 在vc组件实例对象销毁之前解绑在总线的自定义事件，否则其一直存在。一定要在（）内指定解绑的自定义事件对象
   
   },
   ```

## 消息的订阅与发布

1. 订阅消息：消息名（相当于手机号和微信号）
2. 发布消息：消息内容

### 安装pubsub-js库

```js
 npm i pubsub-js 
```

### 引入和使用pubsub

谁用谁就引入

#### 订阅消息

接收数据的一方

```js
  import pubsub from "pubsub-js";

   mounted() {
    // 一旦挂载完毕，就去订阅一个消息
    this.pubId = pubsub.subscribe('hello',(msgName,data)=>{  // pubsub是一个对象，subscribe是这个对象的方法
      console.log('有人发布了hello消息，hello消息的回调执行了',msgName,data); // subName是消息名，data是发过来的数据。
    }) // 回调函数使用箭头函数时的this才是vc实例对象本身
  },
```

#### 发布消息

提供数据的一方

```js
    // 发布一个消息
    pubsub.publish('hello',666); 
```

### 取消订阅

```js
   beforeDestroy() {
    pubsub.unsubscribe(this.pubId); // 利用订阅时产生的Id进行取消
  },
```

### 备注

1. 在引入库时，一般来说，第三方库一般往上靠，自己内部的库靠下。

    ```js
      // 消息订阅
      import pubsub from "pubsub-js";
      import MyFooter from "./components/MyFooter.vue";
      import MyHeader from "./components/MyHeader.vue";
      import MyList from "./components/MyList.vue";
    ```

2. 下划线`_`可用作函数的参数占位

   ```js
   // 消息订阅的回调函数中消息名subName不可少，但是有不被使用，则可以使用下划线变量占参数位。
   deleteTodo(_,id) {
      this.todos = this.todos.filter((todo) => {
        return todo.id !== id;
      });
    }  
   ```

## nextTick

### 语法

`this.$nextTick(回调函数)`

### 作用

在下一次DOM更新结束后执行其指定的回调

```js
  handleEdit(todo) {
      if (Object.prototype.hasOwnProperty.call(todo, "isEdit")) {
        todo.isEdit = true;   // *
      } else {
        console.log("#");
        this.$set(todo, "isEdit", true);
      }
      
      // this.$ref.inputTitle.focus(); // 不奏效，因为input框还未出现（Vue只有等这个回调执行结束才会去解析模板，这时input框才会出现）

      this.$nextTick(function(){ 
        this.$refs.inputTitle.focus();
      })
      console.log(todo);
    },
```

在*行，修改了isEdit的值，input中的v-show要使用这个值。当整个回调函数执行完之后，Vue才会去解析模板，DOM才会更新。相当于异步调用，先去更新DOM，完成之后再回来执行nextTick中的回调函数。

### 什么时候用

当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。

## Vue封装的过渡与动画

### 作用

在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名

### 图示

![image.png](https://pic.rmb.bdstatic.com/bjh/55d04d3e5e76d8c056ea77213a3d7a98.jpeg)

### 写法

准备好样式，无论是自己写还是第三方库

### 使用`<transition>包裹要过渡的元素，并配置name属性`

```js
  <transition name="hello">
      <h1 v-show="isShow">你好啊！</h1>
    </transition>
```

### 第三方集成库 animate.css

npm：<https://www.npmjs.com/package/animate.css>
官网：<https://animate.style/>

#### 安装

```js
  npm install animate.css
```

#### 引入

由于引入的是样式，不是js模块，所以有所区别。

```js
  import 'animate.css'
```

#### 使用

```js
  <transition-group
    appear
    name="animate__animated animate__bounce" // 写死
    enter-active-class="animate__swing" // 进入的动画效果="网站上的动画名"
    leave-active-class="animate__backOutUp" // 同上
  >
    <h1 v-show="!isShow" key="1">你好啊！</h1>
    <h1 v-show="isShow" key="2">大帅哥！</h1>
  </transition-group> // 若有多个元素需要过渡，则需要使用：<transition-group>,且每个元素都要指定key值。
```

## 配置代理

### 发送HTTP请求的三种常见的方式

1. xhr
   太麻烦了，一般不用。
2. jQuery
   主要是封装了对DOM的操作，对http请求的封装只是很小的一部分。一般用了Vue和React框架的前端很少再使用jQuery的http请求了。
3. axios
   体积小，强大。
4. fetch
   会把返回的数据包两层promise，兼容性问题（IE）

### 下载并引入axios

```js
  // 下载
  npm i axios
```

```js
  // 引入
  import axios from 'axios'
```

### 跨域，违背了同源策略

![image.png](https://pic.rmb.bdstatic.com/bjh/f332e8ad41bbff13448d2d6943199760.jpeg)

#### 同源策略规定

1. 协议名
2. 主机名
3. 端口号
以上三者必须一致

原理图
![image.png](https://pic.rmb.bdstatic.com/bjh/4313097750f34428d321209eeeb6fb7f.jpeg)
发送了请求-服务器也响应了-浏览器收到之后发现是跨域-则不会呈现数据。

### 解决办法

1. cors
    在服务器的响应中配置相应的响应头
2. jsonp
    真正开发不怎么用，只能解决get，其他不行。
3. **配置代理服务器 ***
    ![image.png](https://pic.rmb.bdstatic.com/bjh/28d56e9396a3cd5e947791bd3225e710.jpeg)

#### 如何使用vue-cli脚手架配置代理服务器

##### 方式一

<https://cli.vuejs.org/zh/config/#devserver-proxy>

在vue.config.js中配置

```js
  devServer: {
    proxy: 'http://localhost:5000'
  }
```

即当你请求的数据8080端口本身就有的时候，代理服务器8080不会把所有的请求发送给5000服务器。

说明：

 1. 优点：配置简单，请求资源时直接发给前端（8080）即可。
 2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。
 3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器。（如果前端8080中有请求的资源，则会优先匹配前端资源）

##### 方式二

配置多个代理：

```js
  devServer: {
    proxy: {
      '/api': { // 匹配所有以'/api1'开头的请求路径
        target: 'http://localhost:5000', // 代理目标的基础路径
        pathRewrite: { '^/api': '' }, // 匹配所有/api，替换成空字符串。  ^ 符号表示只匹配那些以once开头的字符串。
        // ws: true,  // 默认是true
        // changeOrigin: true  // 默认是true，用于控制请求头中的host值，欺骗5000服务器我这个代理服务器也是来自5000的。
      },
      // 上面的精简版
      /*  '/foo': {
          target: '<other_url>'
       } */
      '/demo': {
        target: 'http://localhost:5001',
        pathRewrite: { '^/demo': '' }, 
      },
    }
  }
```

说明：

1. /api 请求前缀
 想走代理，就加上api；不想走代理，就不加。
2. pathRewrite 路径重写（*）使用正则表达式，如果没有这个，那么请求5000服务器的路径则包含了/api/student，
 然而5000这台服务器根本就没有/api/student路径下的文件，所以会返回404（未发现）。
3. ws: 是用于支持websocket
4. changeOrigin设置为true时，服务器收到的请求头中的host为：localhost: 5000  欺骗
5. changeOrigin设置为false时，服务器收到的请求头中的host为：localhost: 8000 实话实说
6. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。
7. 缺点：配置略微繁琐，请求资源时必须加前缀。

## github案例

- 不要直接把第三方库的css文件放入.vue文件中，不利于后期维护和区分，.vue文件中一般放程序员自己写的东西。
- 把第三方成型的库放在公共的位置
  1. 方式一： 在src中建立静态资源文件夹 assets，放入其中的css文件夹中。 通过import引入，报错‘缺少font字体文件’。这是因为通过import引入时，Vue会进行严格的审查，一旦缺少所需要的资源就会报如下错误：
  ![image.png](https://pic.rmb.bdstatic.com/bjh/e4d5485d3b62f1ba38683fb5c53992ad.jpeg)
  之前在html中通过link标签去引入时，是没有这个检查的。
  所以一旦涉及到使用第三方库，但是出现以上问题的，不推荐使用以上放入assets文件夹的方法。
  2. 方式二：在public文件夹中新建css文件夹，把bootstrap.css文件放入其中。在index.html中通过link标签去引入。
  