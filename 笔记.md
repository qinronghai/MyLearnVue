# 笔记

## ref属性

1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上的是组件实例对象（vc）
3. 使用方式：
   打标识：

    ```js
      <h1 v-text="msg" ref="title"></h1>
      <button ref="btn" @click="showDOM">点我输出上方的DOM元素</button>
      <School ref="sch"></School>
    ```

   获取：

    ```js
    this.$refs.xxx
    ```

   备注：在组件上标识id属性，获取到的是组件的HTML结构。

    ```js
    <School id="sch"></School>
    ```

## 配置项props

功能：让组件接收外部传过来的数据
>更常见于：你有一个组件，但是data中的数据你已经写好了，别人也想用这个组件，但是数据不一样的情况。你可以使用props配置型，所以这样写可能是复用率最高的。

- 父组件给子组件传递数据

### 传递数据

```js
  <Student name='昂劳务' sex='男' :age='18'></Student>
```

### 接收数据（组件内部）

1. 只接收，没有任何限制

  ```js
    props: ['name','sex','age'] // 简单接收
  ```

2. 限制类型

  ```js
    props: {
      name: String,
      age: Number, 
      sex: String
    } 
  ```

3. 限制类型、必要性和指定默认值

  ```js
    props: {
    name: {
      type: String,
      require: true // name是必要的
    },
    age: {
      type: Number,
      default: 99 // 默认值
    },
    sex: {
      type: String,
      require: true
    }
  }
  ```

### 备注

props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告。
如果业务确实需要修改，那么可以赋值props的内容到data中一份，然后渲染和修改data中的数据。

```js
  // html
  <h2>学生年龄：{{ this.ageFlag }}</h2>

  // data
  data() {
    return {
      msg:'我是谁？',
      ageFlag: this.age // *
    }
  },

  //methods
  methods: {
    updateAge(){
      this.ageFlag++;
    }
  },
```

## mixin配置项

用于当两个组件都要相同的东西时，抽离出来写到一个文件中，然后再引入。
可以把多个组件共用的配置提取成一个混入对象。

### 使用方式

1. 定义混合（在单独的文件中）
   把多个组件的相同部分抽离到一个单独的[文件中](.src/mixin.js)中,在组件中是什么样的，在mixin中就是什么样的。

   ```js
    export const mixin = {
      methods: {
        showName(){
          alert(this.name);
        }
      }
    }
    export const dataMixin = {
      data() {
        return {
          testNum: 99
        }
      },
    }
   ```

2. 使用混合
   1. 全局混合：（在[main文件](.src/main.js)中）

   ```js
    import name from 'xxx'
    Vue.mixin(name);
   ```

   2. 局部混合：（在当前组件文件）

   ```js
    import name from 'xxx' 
    mixins:[name,...];
   ```

### 备注

对于mixin混合，若发生冲突，Vue会让原有组件中的配置优先生效。但生命周期函数除外。

## 插件

用于增强Vue
本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的参数数据。

### 定义插件

在一个新的文件夹plugins.js中定义插件：

```js
  export default {
    install(Vue,options) {
      // 1. 添加全局过滤器
      Vue.filter(...)

      // 2. 添加全局指令
      Vue.directive(...)

      // 3. 配置全局混合
      Vue.mixin(...)

      // 4. 在原型上添加方法
      Vue.prototype.$myMethod=function am(params) {
        
      }
      Vue.prototype.$myProperty=xxx
    }
}
```

### 使用插件

```js
  import plugin from './src/plugins.js' // 在new Vue之前。
  Vue.use($插件名)
```

## scoped样式

### 引入问题

:question:在多个组件中，多个组件的样式虽然是分开设置的，但最后（浏览器渲染时）Vue还是会合到一张样式表中，这就有可能造成样式class重名的问题。

### 解决

- 当重叠时，谁在APP中最后引入，就以谁为准。
- App组件中写的样式不适合使用scoped属性，因为所有的组件都汇总到了App组件，它的样式应该用来写全局样式比较。

  ```html
  <style scoped lang='less'>
    .demo2 {
      background-color: orange;
      .qwe {
        font-size: 40px;
      }
    }
  </style>
  ```

- scoped属性的实现原理=>**属性选择器**
![image.png](https://pic.rmb.bdstatic.com/bjh/19ead2a9001dc8bcc4dc2608999d02d3.jpeg)
![image.png](https://pic.rmb.bdstatic.com/bjh/ba6c862bac0f1b46556b610bf2d221a8.jpeg)
- style中的lang属性是css预编译语言，如lang='less',但是脚手架处理不了less，需要安装less。命令：

  ```js
  npm i less-loader
  ```

- 查看webpack的版本

  ```js
  npm view webpack versions
  ```

## 组件化编码流程（通用）

最忌讳的是给你一个需求，你拿过来直接就写，想都不想。

### 实现静态组件

抽取组件，使用组件实现静态页面效果。

1. 分析一共可以拆分成多少组件。
2. 组件的划分是按照功能点来划分的。
3. 有时候你拆完组件之后，感觉很难给起名，那么就有可能意味着**拆得不合理**。
    ![image.png](https://pic.rmb.bdstatic.com/bjh/b75b490b68966569c346fd06d522b656.jpeg)
4. 开发中，组件起名都是多个单词组成的。eg：个人中心的头部 => `UserHeader`。
5. 整体组件的层级引入搭建好。

- id的生成：uuid和nanoid
  安装nanoid库:

  ```js
    npm i nanoid
  ```

  引入nanoid

  ```js
    // 引入nanoid
    import {nanoid} from 'nanoid'
  ```

  使用nanoid

  ```js
    nanoid();  // 是一个函数，返回相应的字符串。
  ```

### 展示动态数据

### 交互--从绑定事件监听开始

![image.png](https://pic.rmb.bdstatic.com/bjh/59e551102b98f81c4a6706b478d9b636.jpeg)

- 数据在哪，那么对数据的操作就应该在哪里的methods中
- 不建议使用v-model修改props传过来的数据
![image.png](https://pic.rmb.bdstatic.com/bjh/fb9cd874b4752dea5822c942dfdafa0a.jpeg)
props是只读的，虽然props只是执行了浅层的监视（即修改对象中的某个属性的值时，props是监测不到的--这里是todo对象中的completed）。

## TODO案例总结

1. 组件化编码流程：
    1. 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突
    2. 实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件再用：
        1. 一个组件在用：放在组件自身即可。
        2. 一些组件在用：放在他们共同的父组件上（状态提升）。
        1. 实现交互：从绑定事件开始。
2. props传输数据适用于：
   1. 父组件==》子组件 通信
   2. 子组件==》父组件 通信 （要求父先给子一个函数）
3. 使用v-model时要切记：v-model绑定的值不能时props传过来的值，因为props是不可以被修改的。
4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。

## WebStorage

浏览器端通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制。

存储内容大小一般支持5MB左右（不同浏览器可能不一样）

### localStorage

本地存储，需要手动清除才会消失。

### sessionStorage

会话存储，浏览器关闭之后会消失。

### 相关API

localStorage和sessionStorage属性的API完全相同

- `xxxxStorage.setItem('key','value');`

 ​  该方法接收一个键和值作为参数，会把键值对放入存储中，如果键值名忖左，则更新其对应的值。

- `xxxxStorage.getItem('key');`

 ​  该方法接收一个键名作为参数，返回键名对应的值。

- `xxxxStorage.removeItem('key');`

 ​  该方法接收一个键名作为参数，并把该键名从存储中删除。

- `xxxxStorage.clearItem();`

 ​  该方法会清空存储中的所有数据。

### 备注

1. `xxxxStorage.getItem('key');`中key不在存储中，那么返回的是`null`
2. `JSON.parse(null)`的结果依然是`null`

## 组件自定义事件

>JS的内置事件如click、keyup等是用于HTML元素的
 组件自定义事件是给组件用的

### 回顾子给父传递事件的另一个方法“使用props进行传递数据”

```js
  // 1.在父组件的子组件标签中使用props传递一个函数
  <School :getSchoolName="getSchoolName"></School> 
  // 2.在子组件的props中接收这个函数
  props: ["getSchoolName"],
  // 3.在子组件中使用这个函数，并传递此子组件的数据
  methods: {
    sendSchoolName() {
      console.log("发送了学校名字");
      this.getSchoolName(this.name); // 父组件穿过来的函数被调用，子组件的数据被传递过去了。
    },
  },
  // 4.在父组件中使用接收到的子组件的数据
  methods: {
  getSchoolName(schoolName) {
    console.log("App收到了学校名", schoolName);
  }, 
```

### 自定义组件的作用

适用于 子组件 给 父组件 传递数据

### 自定义组件如何用于子给父传递事件

#### 方法一：通过给子组件标签绑定一个自定义事件实现

在父组件的子组件标签中给子组件绑定自定义事件

1. `<Demo @selfSet="test"/>`
2. `<Demo v-on:selfSet="test"/>`
  
```js
  // 在父组件的子组件标签中给子组件绑定自定义事件
  <Student v-on:selfSet="getStudentName" @demo="m1"></Student> // 自定义事件中的回调函数写在父组件中
  // 在子组件中触发自定义事件
  // 触发student组件实例身上的selfSet事件
  this.$emit("selfSet", this.name, 666, 888, 900);  // 事件触发后，在父组件中的getStudentName函数被调用，从而达到从子组件向父组件传递数据。
```

#### 方法二：使用ref属性

```js
  // 在父组件的子组件标签中使用ref打标识
  <Demo ref="demo"/>
  // 在父组件中
  mounted() {
    this.$refs.student.$on("selfSet", this.getStudentName); // 绑定自定义事件
    // this.$refs.student.once("selfSet", this.getStudentName); // 绑定自定义事件(一次性)
  },
```

#### 备注

1. 触发自定义事件：`this.$emit('selfSet',数据)`
2. 解绑自定义事件：`this.$off('selfSet')`
3. 组件上也可以绑定原生DOM事件，需要使用`.native`修饰符
4. 注意：通过`this.$refs.student.$on("selfSet", this.getStudentName);`绑定自定义事件时，回调要么配置在methods中，要么使用箭头函数，否则this指向会出问题。

## 全局事件总线(GlobalEventBus)

原理图：
![image.png](https://pic.rmb.bdstatic.com/bjh/e54578929df8ac303cb9c1ccb7d4d776.jpeg)

全局事件总线是一种组件间通信的方式，适用于任意组件间的通信。

### 安装全局事件总线

```js
  // 创建vm
  new Vue({
    ......
    beforeCreate() {
      Vue.prototype.$bus = this // 安装全局事件总线，$bus就是当前应用的vm
    },
    ......
  })
```

### 使用事件总线

1. 接收数据组件：A组件想要接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。

   ```js
    // 方法一：回调函数使用箭头函数
      mounted() {
        // console.log("School", this.x);
        this.$bus.$on("sendName", (data) => {
          console.log("我是School组件，收到了数据", data);
        });
      },
    // 方法二：回调函数提前在methods中定义
    methods: {
      demo(data){
        ...
      }
    },
    mounted() {
      // console.log("School", this.x);
      this.$bus.$on("sendName", this.demo);
    },
   ```

2. 提供数据的组件：`this.$bus.$emit('xxx',data)`
3. 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。

   ```js
    beforeDestroy() {
     this.$bus.$off('sendName');  // 在vc组件实例对象销毁之前解绑在总线的自定义事件，否则其一直存在。一定要在（）内指定解绑的自定义事件对象

   },
   ```

## 消息的订阅与发布

1. 订阅消息：消息名（相当于手机号和微信号）
2. 发布消息：消息内容

### 安装pubsub-js库

```js
 npm i pubsub-js 
```

### 引入和使用pubsub

谁用谁就引入

#### 订阅消息

接收数据的一方

```js
  import pubsub from "pubsub-js";

   mounted() {
    // 一旦挂载完毕，就去订阅一个消息
    this.pubId = pubsub.subscribe('hello',(msgName,data)=>{  // pubsub是一个对象，subscribe是这个对象的方法
      console.log('有人发布了hello消息，hello消息的回调执行了',msgName,data); // subName是消息名，data是发过来的数据。
    }) // 回调函数使用箭头函数时的this才是vc实例对象本身
  },
```

#### 发布消息

提供数据的一方

```js
    // 发布一个消息
    pubsub.publish('hello',666); 
```

### 取消订阅

```js
   beforeDestroy() {
    pubsub.unsubscribe(this.pubId); // 利用订阅时产生的Id进行取消
  },
```
